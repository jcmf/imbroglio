// Generated by IcedCoffeeScript 1.8.0-d
(function() {
  var compile, parseOutIn, parseText, prepare, quote, render, _tag, _text,
    __slice = [].slice;

  exports.quote = quote = function(s) {
    s = s.replace(/([\\'])/g, '\\$1').replace(/\n/g, '\\n').replace(/\r/g, '\\r');
    return "'" + s + "'";
  };

  parseOutIn = function(re, text, mkOutList, mkInItem) {
    var idx, item, m, result, _i, _j, _len, _len1, _ref, _ref1;
    idx = 0;
    result = [];
    while (m = re.exec(text)) {
      _ref = mkOutList(text.substring(idx, m.index));
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        result.push(item);
      }
      idx = re.lastIndex;
      result.push(mkInItem(m));
    }
    _ref1 = mkOutList(text.substring(idx));
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      item = _ref1[_j];
      result.push(item);
    }
    return result;
  };

  parseText = function(text) {
    return ["_text(" + (quote(text)) + ")"];
  };

  exports.compile = compile = function(src, opts) {
    var XXX, YYY, code, codeBegin, codeEnd, e, end, error, found, idx, js, p, piece, pieces, pp, start;
    if (opts == null) {
      opts = {};
    }
    codeBegin = '#{';
    codeEnd = '}';
    pp = (function() {
      var _i, _j, _k, _l, _len, _len1, _ref, _ref1, _results;
      _ref = src.split(/\n\s*\n/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        if (!/\S/.test(p)) {
          continue;
        }
        pieces = [];
        idx = 0;
        for (XXX = _j = 0; _j <= 99; XXX = ++_j) {
          found = p.indexOf(codeBegin, idx);
          if (found < 0) {
            found = p.length;
          }
          _ref1 = parseText(p.substring(idx, found));
          for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
            piece = _ref1[_k];
            pieces.push(piece);
          }
          if (found === p.length) {
            break;
          }
          start = found + codeBegin.length;
          end = start - 1;
          error = true;
          for (YYY = _l = 0; _l <= 99; YYY = ++_l) {
            end = p.indexOf(codeEnd, end + 1);
            if (end < 0) {
              idx = p.length;
              break;
            }
            code = p.substring(start, end);
            try {
              js = require('iced-coffee-script').compile(code);
            } catch (_error) {
              e = _error;
              error = e;
              continue;
            }
            error = null;
            pieces.push(js.replace(/;\s*$/, ''));
            idx = end + codeEnd.length;
            break;
          }
          if (error) {
            pieces.push("_tag('span', {'class': 'error'}, _text(" + (quote(codeBegin)) + "))");
            idx = start;
          }
        }
        _results.push("_tag('p', {}, " + (pieces.join(', ')) + ")");
      }
      return _results;
    })();
    return "return [" + (pp.join(', ')) + "];";
  };

  exports._tag = _tag = function() {
    var attrs, child, children, k, name, result, v, _i, _len;
    name = arguments[0], attrs = arguments[1], children = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    if (attrs == null) {
      attrs = {};
    }
    result = document.createElement(name);
    for (k in attrs) {
      v = attrs[k];
      result.setAttribute(k, v);
    }
    for (_i = 0, _len = children.length; _i < _len; _i++) {
      child = children[_i];
      result.appendChild(child);
    }
    return result;
  };

  exports._text = _text = function(text) {
    return document.createTextNode(text);
  };

  exports.prepare = prepare = function(src, opts) {
    return new Function('_tag', '_text', compile(src, opts)).bind(null, _tag, _text);
  };

  exports.render = render = function(src, opts) {
    return prepare(src, opts)();
  };

}).call(this);
