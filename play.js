// Generated by IcedCoffeeScript 1.8.0-d
(function() {
  var choiceChars, error, game, hashchange, mkElem, mkText, newGame, restore;

  choiceChars = '0123456789abcdefghijklmnopqrstuvwxyz';

  error = function(msg) {
    throw new Error(msg);
  };

  mkText = function(s) {
    return window.document.createTextNode(s);
  };

  mkElem = function(tag, children, attrs) {
    var child, k, result, v, _i, _len;
    if (children == null) {
      children = [];
    }
    if (attrs == null) {
      attrs = {};
    }
    result = window.document.createElement(tag);
    for (k in attrs) {
      v = attrs[k];
      result.setAttribute(k, v);
    }
    for (_i = 0, _len = children.length; _i < _len; _i++) {
      child = children[_i];
      if (child) {
        result.appendChild(child);
      }
    }
    return result;
  };

  newGame = (function() {
    var firstPassage, passages, src;
    src = require('fs').readFileSync("" + __dirname + "/game.txt", 'utf8');
    passages = {};
    firstPassage = null;
    (function() {
      var lastPassage, m, re;
      re = /(?:^|\n\n)#\s+([^\n]*\S)\n/g;
      lastPassage = null;
      while (m = re.exec(src)) {
        if (lastPassage) {
          lastPassage.endIndex = m.index;
        }
        lastPassage = {
          name: m[1],
          startIndex: re.lastIndex
        };
        assert(!(lastPassage.name in passages), lastPassage.name);
        passages[lastPassage.name] = lastPassage;
        firstPassage || (firstPassage = lastPassage);
      }
      return lastPassage.endIndex = src.length;
    })();
    return (function() {
      var k, v, _results;
      _results = [];
      for (k in passages) {
        v = passages[k];
        _results.push((function() {
          var re;
          v.src = src.substring(v.startIndex, v.endIndex);
          return re = /\[\[([^\]]*)\]\]|(\n\n)/g;
        })());
      }
      return _results;
    })();
  })();

  game = null;

  restore = function(moves) {
    var $output, $p, ch, last, _i, _len, _ref;
    if ((game != null ? game.moves : void 0) === moves) {
      return;
    }
    $('#loading').show();
    $('.pane').hide();
    $('#game').hide();
    $output = $('#output');
    if (!game) {
      game = newGame();
      $output.empty();
    } else {
      last = function() {
        var children;
        children = $output.children();
        if (children.length) {
          return $(children.get(children.length - 1));
        } else {
          return children;
        }
      };
      while (game.moves !== moves.slice(0, game.moves.length)) {
        last().remove();
      }
      last().find('.chosen').removeClass('chosen');
    }
    _ref = moves.slice(game.moves.length);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      ch = _ref[_i];
      if (!(game = game.choose(ch))) {
        $('#404-pane').show();
        $('#loading').hide();
        return;
      }
      $(game.chosenElem).addClass('chosen');
      $output.append(game.passageElem);
    }
    $('#game').show();
    $('#loading').hide();
    $p = $(game.passageElem);
    return window.scrollTo(0, $p.offset().top - $p.css('margin-top'));
  };

  hashchange = function() {
    var hash, m, target;
    hash = window.location.hash.replace(/^#/, '');
    if (m = /^!(.*)$/.exec(hash)) {
      return restore(hash(m[1]));
    }
    game = target = null;
    if (m = /^\/([a-z][a-z-]*)$/.exec(hash)) {
      target = $("#" + m[1] + "-pane");
    }
    if (!(target != null ? target.length : void 0)) {
      target = $('#home');
    }
    $('#game').hide();
    $('#output').empty();
    $('.pane').hide();
    target.show();
    return window.scrollTo(0, 0);
  };

  $(function() {
    $(window).on('hashchange', function(e) {
      e.preventDefault();
      hashchange();
      return true;
    });
    return hashchange();
  });

}).call(this);
